# 性能优化-内存溢出

## 内存溢出

内存溢出：OOM，是 Out of Memory 的缩写，指的是 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后，而被系统强杀掉的现象。OOM 其实也属于应用“崩溃”中的一种，是由 iOS 的 Jetsam 机制导致的一种“另类”崩溃，并且日志无法通过信号捕捉到。

注意：内存泄漏堆积后的后果就是内存溢出。

## 内存溢出监控手段

### 线下监控手段

1. 通过 XNU 获取内存限制值：通过 XNU 的宏获取内存限制，需要有 root 权限，而 App 内的权限是不够的，所以正常情况下，作为 App 开发者你是看不到这个信息的。那么，需要越狱去获取这个权限。
2. Instruments-Allocations：跟踪进程的匿名虚拟内存和堆，为对象提供类名和可选的 retain、release历史记录。可以查看虚拟内存占用、堆信息、对象信息、调用栈信息，VM Regions 信息等。可以利用这个工具分析内存，并针对地进行优化。

注意：1是需要线下进行越狱获取权限，2是Instruments-Allocations如何线下监控内存溢出有待验证。

### 线上监控手段

1. 通过 JetsamEvent 日志计算内存限制值：查看手机中以 JetsamEvent 开头的系统日志（我们可以从设置 -> 隐私 -> 分析中看到这些日志）。
2. 通过内存警告获取内存限制值： 可以利用 didReceiveMemoryWarning 这个内存压力代理事件来动态地获取内存限制值。iOS 系统在强杀掉 App 之前还有 6 秒钟的时间，足够你去获取记录内存信息了。

注意：1是获取内存上限值，2是监控到 App 因为占用内存过大而被强杀的时机，然后获取当前内存使用情况，一般使用这两个。

## 内存问题信息收集

1. 内存分配函数 malloc 和 calloc 等默认使用的是 nano_zone。nano_zone 是 256B 以下小内存的分配，大于 256B 的时候会使用 scalable_zone 来分配。
2. 这里主要是针对大内存的分配监控，所以只针对 scalable_zone 进行分析，同时也可以过滤掉很多小内存分配监控。比如，malloc 函数用的是 malloc_zone_malloc，calloc 用的是 malloc_zone_calloc。
3. 使用 scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统总是需要有一个地方来统计并管理内存的分配情况。（malloc_zone_malloc 函数中，在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录。）
4. 可以使用 fishhook 去 Hook 这个函数，加上自己的统计记录就能够通盘掌握内存的分配情况。出现问题时，将内存分配记录的日志捞上来，你就能够跟踪到导致内存不合理增大的原因了。

## 通过内存警告线上监控

1. 利用 didReceiveMemoryWarning 这个内存压力代理事件来动态地获取内存限制值。
2. iOS 系统在强杀掉 App 之前还有 6 秒钟的时间，足够你去获取记录内存信息。
3. 如何获取当前内存使用情况？iOS 系统提供了一个函数 task_info， 可以帮助我们获取到当前任务的信息。
4. 要想精确地定位问题，我们就需要 dump 出完整的内存信息，包括所有对象及其内存占用值，在内存接近上限值的时候，收集并记录下所需信息，并在合适的时机上报到服务器里，方便分析问题。
5. 获取到了每个对象的内存占用量还不够，你还需要知道是谁分配的内存，这样才可以精确定位到问题的关键所在。一个对象可能会在不同的函数里被分配了内存并被创建了出来，当这个对象内存占用过大时，如果不知道是在哪个函数里创建的话，问题依然很难精确定位出来。
6. 可以使用 fishhook 去 Hook 这个 malloc_logger 函数，加上自己的统计记录就能够通盘掌握内存的分配情况。出现问题时，将内存分配记录的日志捞上来，你就能够跟踪到导致内存不合理增大的原因了。

## 内存溢出线下监控工具

### Instruments-Allocations

1. Instruments-Allocations：跟踪进程的匿名虚拟内存和堆，为对象提供类名和可选的 retain、release历史记录。可以查看虚拟内存占用、堆信息、对象信息、调用栈信息，VM Regions 信息等。可以利用这个工具分析内存，并针对地进行优化。
2. 注意：Instruments-Allocations如何线下监控内存溢出有待验证。

## 内存使用量的线上监控方法

1. 在获取 iOS 应用内存使用量时，都是使用 task_basic_info 里的 resident_size 字段信息。但是，我们发现这样获得的内存使用量和 Instruments 里看到的相差很大。
2. 内存信息存在 task_info.h （完整路径 usr/include/mach/task.info.h）文件的 task_vm_info 结构体中，其中 phys_footprint 就是物理内存的使用，而不是驻留内存 resident_size。
3. 类似于对 CPU 使用率的监控，我们只要从这个结构体里取出 phys_footprint 字段的值，就能够监控到实际物理内存的使用情况了。
4. 线上性能监控方案代码和业务逻辑是完全解耦的，监控时基本都是直接获取系统本身提供的数据，没有额外的计算量，因此对 App 本身的性能影响也非常小。

## 内存泄漏和溢出

1. 内存泄漏(Memory Leak)：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
2. 内存溢出(Memory Overflow)：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。
3. 内存泄漏的堆积最终会导致内存溢出。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
4. OOM，是 Out of Memory 的缩写，指的是 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后，而被系统强杀掉的现象
5. OOM 其实也属于应用“崩溃”中的一种，是由 iOS 的 Jetsam 机制导致的一种“另类”崩溃，并且日志无法通过信号捕捉到。

## leaks和allocations工具

1. Instrument-leaks：测量内存使用情况，检查泄漏内存，并按照类来提供对象分配的统计信息，以及所有活动分配和泄漏内存地址历史信息。
2. Instrument-allocations：跟踪进程的匿名虚拟内存和堆，为对象提供类名和可选的 retain、release历史记录。可以查看虚拟内存占用、堆信息、对象信息、调用栈信息，VM Regions 信息等。可以利用这个工具分析内存，并针对地进行优化。

## 项目线下检测

Instrument - Allocations：可以查看虚拟内存占用、堆信息、对象信息、调用栈信息，VM Regions 信息等。可以利用这个工具分析内存，并针对地进行优化，如下图所示：

![[Instrument Allocations 检查内存溢出.png]]


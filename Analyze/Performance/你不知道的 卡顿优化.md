## 列表卡顿如何优化

cpu
1. 尽量使用轻量级对象，如果用不到事件处理，使用calayer代替uiview
2. 避免频繁调用view相关属性，比如布局相关frame、bounds等
3. 不要多次修改属性，尤其是属性内图片宽高布局，cell高度，提前计算好，需要时一次性设置
4. 把耗时操作比如文本尺寸计算、绘制，图片解码、绘制，放到子线程处理
5. 控制线程的最大并发数量，并发过多也会造成性能损耗
6. 考虑使用frame代替autolayout，后者消耗更多cpu资源

gpu
1. 避免短时间大量图片显示
2. 多张图片考虑合成一张图片显示
3. 注意不要超过gpu处理的最大纹理尺寸
4. 尽量减少视图数量和层次
5. 减少透明的视图
6. 圆角阴影处理，避免出现离屏渲染

## 优化前后的情况？
1. fps指示器 FPSLabel，用到了 CADisplayLink 来监视 CPU 的卡顿问题
2. 优化前 25 fps - 30 fps，感受到明显卡顿
3. 优化后稳定在 50 fps - 60 fps，快速滑动感受不到卡顿，足够流畅

## 离屏渲染场景？

1. 业务
    1. 列表cell处理圆角和阴影
    2. 头像、按钮圆角阴影
2. 操作
    1. 遮罩
    2. 圆角
    3. 阴影

## 离屏渲染过程？

1. gpu有两种渲染方式，当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
2. 当某些操作比如光栅化、遮罩、圆角、阴影，会触发离屏渲染
3. 离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区用于渲染操作
4. 渲染过程中，需要多次切换上下文环境，先从on-screen切换到off-screen，渲染结束后，将离屏缓冲区渲染结果显示到屏幕上，又需要将上下文环境从off-screen切换回on-screen
5. 创建和切换环境带来了性能上的消耗

## runloop 如何监控卡顿？

1. 首先，创建一个 observerCtx 观察者
2. 将创建好的观察者添加到主线程 runloop 的 common 模式下观察
3. 然后，创建一个持续的子线程用于监控主线程的 runloop 状态 (do while)
4. 创建一个 dispatch_semphore_wait 信号量，超时时间阈值设置为 3 s，小于 watchdog 限制时间即可
5. 如果下面判断信号量大于0，那么表示信号量等待时间超过3ms，放开了锁
6. 如果 observer 正好处于 BeforeSources 或 AfterWaiting 状态
7. 即可发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿
8. 接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长
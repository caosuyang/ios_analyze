## crash崩溃与收集

### crash日志如何分析堆栈？

1. 我们采集到的崩溃日志，主要包含的信息为：进程信息、基本信息、异常信息、线程回溯。
2. 进程信息：崩溃进程的相关信息，比如崩溃报告唯一标识符、唯一键值、设备标识；
3. 基本信息：崩溃发生的日期、iOS 版本；
4. 异常信息：异常类型、异常编码、异常的线程；
5. 线程回溯：崩溃时的方法调用栈
6. 通常情况下，我们分析崩溃日志时最先看的是异常信息，分析出问题的是哪个线程，在线程回溯里找到那个线程；然后，分析方法调用栈，符号化后的方法调用栈可以完整地看到方法调用的过程，从而知道问题发生在哪个方法的调用上
7. 方法调用栈顶，就是最后导致崩溃的方法调用。完整的崩溃日志里，除了线程方法调用栈还有异常编码。异常编码，就在异常信息里
8. 一些被系统杀掉的情况，我们可以通过异常编码来分析
9. 0x8badf00d 这种情况是出现最多的。当出现被 watchdog 杀掉的情况时，我们就可以把范围控制在主线程被卡的情况
10. 0xdeadfa11 的情况，是用户的主动行为，我们不用太关注
11. 0xc00010ff 这种情况，就要对每个线程 CPU 进行针对性的检查和优化

### 如何crash降低，具体做法？
### 造成 crash 的情况？

1. 造成crash情况千奇百怪，项目针对常见部分崩溃情况做容错处理，比如信号可捕获的崩溃，信号不可捕获的崩溃
2. KVO 问题、NSNotification 线程问题、数组越界、野指针等崩溃信息，是可以通过信号捕获的
3. 像后台任务超时、内存被打爆、主线程卡顿超阈值等信息，是无法通过信号捕捉到的
4. 方法找不到异常报错，可以使用消息动态解析和消息转发容错
5. 后台崩溃容错，Background Task 这种方式，就是系统提供 beginBackgroundTaskWithExpirationHandler 方法来延长后台执行时间，可以解决你退后台后还需要一些时间去处理一些任务的诉求
6. 严格控制后台数据的读写操作。比如，你可以先判断需要处理的数据的大小，如果数据过大，也就是在后台限制时间内或延长后台执行时间后也处理不完的话，可以考虑在程序下次启动或后台唤醒时再进行处理
7. 内存打爆，当监控系统内存的线程发现某 App 内存有压力了，就发出通知，内存有压力的 App 就会去执行对应的代理，也就是你所熟悉的 didReceiveMemoryWarning 代理。通过这个代理，你可以获得最后一个编写逻辑代码释放内存的机会。这段代码的执行，就有可能会避免你的 App 被系统强杀
8. 在后台返回值为Null为空时，我们代码没有判断时，程序就会崩溃，对null做容错处理。

### crash优化前后情况？

1. 崩溃率（也就是一段时间内崩溃次数与启动次数之比）作为优先级最高的技术指标，比如千分位是生死线，万分位是达标线等，去衡量一个 App 的高可用性
2. 崩溃率优化前 0.7% 以上，优化后稳定在 0.3% 以内

## 容错机制

### iOS 如何做项目容错处理？

1. 这里项目容错指的是对数据的容错，数据一般是从后台返回到前端
2. 在团队协作开发当中，由于每个团队成员的⽔平不⼀，很难控制代码的质量，保证代码的健壮性，经常会发⽣由于后台返回异常数据造成app崩溃闪退的情况
3. 为了避免这样的情况项⽬中做⼀些容错处理，显得格外重要，极⼤程度上降低了因为数据容错不到位产⽣崩溃闪退的概率。
4. 例如：
	1.字典
	2.数组；
	3.野指针；
	4.NSNull

### 如果项目开始容错处理没做，如何防止拦截潜在的崩溃？（潜在的==运行时、事后处理）

1、category给类添加⽅法⽤来替换掉原本存在潜在崩溃的⽅法。
2、利⽤runtime⽅法交换技术，将系统⽅法替换成类添加的新⽅法。
3、利⽤异常的捕获来防⽌程序的崩溃，并且进⾏相应的处理
4、总结：
	1、不要过分相信服务器返回的数据会永远的正确。
	2、在对数据处理上，要进⾏容错处理，进⾏相应判断之后再处理数据，这是⼀个良好的编程习惯。

### 字典怎么去容错？

1. 网络请求时去处理：如果使用是AFNetwork做网络请求的话，可以用removesKeysWithNullValues，会自动去除空值
2. 请求后拿到字典数据时：字符串匹配。在获取到服务器返回的Json时(返回结果是string对象)通过stringByReplacingOccurrencesOfString方法，替换"null"为"空字符"，然后解析
2. 事后拦截：使用 runtime，在运行时操作，把空值置为nil，而nil是安全的，可以向nil对象发送任何message而不会奔溃

### 后台返回 null，前端接收的是什么类型？

1. NSNull 对象
2. NSNull和nil的区别在于，nil是一个空对象，已经完全从内存中消失了，而如果我们想表达“我们需要有这样一个容器，但这个容器里什么也没有”的观念时，我们就用到NSNull，我称它为“值为空的对象”。
3. 如果你查阅开发文档你会发现NSNull这个类是继承NSObject，并且只有一个“+ (NSNull *) null；”类方法。这就说明NSNull对象拥有一个有效的内存地址，所以在程序中对它的任何引用都是不会导致程序崩溃的。
4. 这里其实不是完全的，例如从服务器取回来的数据，如果其中有一个NSNUll对象的字典或者数组，那么就会出错

### nil、Nil、NSULL、NULL之间的区别

1. Nil：nil和Nil在使用上是没有严格限定的，也就是说凡是使用nil的地方都可以用Nil来代替，反之亦然。只不过从编程人员的规约中我们约定俗成地将nil表示一个空对象，Nil表示一个空类
2. NULL：Object-C来源于C、支持于C,当然也有别于C。而NULL就是典型C语言的语法，它表示一个空指针
3. NSULL：NSNull和nil的区别在于，nil是一个空对象，已经完全从内存中消失了，而如果我们想表达“我们需要有这样一个容器，但这个容器里什么也没有”的观念时，我们就用到NSNull，我称它为“值为空的对象”
4. nil：给对象赋值时一般会使用object = nil，表示我想把这个对象释放掉，或者经过多次release，于是对象引用计数器为0了，系统将这块内存释放掉，这个时候这个对象为nil，我称它为“空对象”。

### crash 率减低前后情况？

1. 崩溃率（也就是一段时间内崩溃次数与启动次数之比）作为优先级最高的技术指标，比如千分位是生死线，万分位是达标线等，去衡量一个 App 的高可用性
2. 崩溃率优化前 0.7% 以上，优化后稳定在 0.3% 以内